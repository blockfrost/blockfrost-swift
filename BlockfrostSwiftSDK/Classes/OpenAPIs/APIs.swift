// APIs.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Alamofire

open class BlockfrostConfig {
    public static let USER_AGENT = "BlockfrostSwiftSDK"
    public static let URL_MAINNET = "https://cardano-mainnet.blockfrost.io/api/v0"
    public static let URL_TESTNET = "https://cardano-testnet.blockfrost.io/api/v0"
    public static let URL_IPFS = "https://ipfs.blockfrost.io/api/v0"

    public static var DEFAULT_COUNT = 100
    public static var DEFAULT_PAGE = 1
    public static var DEFAULT_SORT_ORDER = SortOrder.asc
    public static var DEFAULT_BATCH_SIZE = 10

    public var basePath = URL_MAINNET
    public var customHeaders: [String: String] = [:]
    public var credential: URLCredential?
    public var projectId: String?
    public var requestBuilderFactory: RequestBuilderFactory = AlamofireRequestBuilderFactory()  // URLSessionRequestBuilderFactory() is not supported
    public var apiResponseQueue: DispatchQueue = .main
    public var batchSize: Int = DEFAULT_BATCH_SIZE
    public var timeout: TimeInterval? = nil

    // Alamofire dependent
    public var retryPolicy: RetryPolicy? = BlockfrostRetryPolicy()
    public var urlSessionConfigurationModifier: ((URLSessionConfiguration)->())? = nil

    public init(basePath: String? = nil, projectId: String? = nil, apiResponseQueue: DispatchQueue? = nil, batchSize: Int? = nil, retryPolicy: RetryPolicy? = nil, timeout: TimeInterval? = nil) {
        if let x = basePath { self.basePath = x }
        if let x = projectId { self.projectId = x }
        if let x = apiResponseQueue { self.apiResponseQueue = x }
        if let x = batchSize { self.batchSize = x }
        if let x = retryPolicy { self.retryPolicy = x }
        if let x = timeout { self.timeout = x }
    }

    private static var sharedInstance: BlockfrostConfig = {
        let instance = BlockfrostConfig(basePath: BlockfrostConfig.URL_MAINNET, projectId: BlockfrostConfig.getEnvProjectId() ?? BlockfrostConfig.getEnvProjectIdMainnet())
        return instance
    }()

    private static var sharedInstanceMainnet: BlockfrostConfig = {
        let instance = BlockfrostConfig(basePath: BlockfrostConfig.URL_MAINNET, projectId: BlockfrostConfig.getEnvProjectId() ?? BlockfrostConfig.getEnvProjectIdMainnet())
        return instance
    }()

    private static var sharedInstanceTestnet: BlockfrostConfig = {
        let instance = BlockfrostConfig(basePath: BlockfrostConfig.URL_TESTNET, projectId: BlockfrostConfig.getEnvProjectId() ?? BlockfrostConfig.getEnvProjectIdTestnet())
        return instance
    }()

    private static var sharedInstanceIpfs: BlockfrostConfig = {
        let instance = BlockfrostConfig(basePath: BlockfrostConfig.URL_IPFS, projectId: BlockfrostConfig.getEnvProjectId() ?? BlockfrostConfig.getEnvIpfsProjectId())
        return instance
    }()
    
    public class func shared() -> BlockfrostConfig {
        sharedInstance
    }

    public class func testnetDefault() -> BlockfrostConfig {
        sharedInstanceTestnet
    }

    public class func mainnetDefault() -> BlockfrostConfig {
        sharedInstanceMainnet
    }

    public class func ipfsDefault() -> BlockfrostConfig {
        sharedInstanceIpfs
    }

    public func clone() -> BlockfrostConfig {
        let r = BlockfrostConfig()
        r.basePath = basePath
        r.customHeaders = customHeaders
        r.credential = credential
        r.projectId = projectId
        r.requestBuilderFactory = requestBuilderFactory
        r.apiResponseQueue = apiResponseQueue
        r.retryPolicy = retryPolicy
        r.urlSessionConfigurationModifier = urlSessionConfigurationModifier
        return r
    }

    public class func getEnvProjectId() -> String? {
        ProcessInfo.processInfo.environment["BF_PROJECT_ID"]
    }

    public class func getEnvProjectIdMainnet() -> String? {
        ProcessInfo.processInfo.environment["BF_MAINNET_PROJECT_ID"]
    }

    public class func getEnvProjectIdTestnet() -> String? {
        ProcessInfo.processInfo.environment["BF_TESTNET_PROJECT_ID"]
    }

    public class func getEnvIpfsProjectId() -> String? {
        ProcessInfo.processInfo.environment["BF_IPFS_PROJECT_ID"]
    }
}

open class BlockfrostStaticConfig {
    public static var basePath: String {
        get { BlockfrostConfig.shared().basePath }
        set { BlockfrostConfig.shared().basePath = newValue }}
    public static var customHeaders: [String: String] {
        get { BlockfrostConfig.shared().customHeaders }
        set { BlockfrostConfig.shared().customHeaders = newValue }}
    public static var credential: URLCredential? {
        get { BlockfrostConfig.shared().credential }
        set { BlockfrostConfig.shared().credential = newValue }}
    public static var projectId: String? {
        get { BlockfrostConfig.shared().projectId }
        set { BlockfrostConfig.shared().projectId = newValue }}
    public static var requestBuilderFactory: RequestBuilderFactory {
        get { BlockfrostConfig.shared().requestBuilderFactory }
        set { BlockfrostConfig.shared().requestBuilderFactory = newValue }}
    public static var apiResponseQueue: DispatchQueue {
        get { BlockfrostConfig.shared().apiResponseQueue }
        set { BlockfrostConfig.shared().apiResponseQueue = newValue }}
    public static var batchSize: Int {
        get { BlockfrostConfig.shared().batchSize }
        set { BlockfrostConfig.shared().batchSize = newValue }}
}

open class BlockfrostRetryPolicy : RetryPolicy {
    /// The default HTTP status codes to retry.
    /// See [RFC 2616 - Section 10](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10) for more information.
    public static let bfDefaultRetryableHTTPStatusCodes: Set<Int> = [408, // [Request Timeout](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.9)
                                                                   429, // [Rate limited](https://docs.blockfrost.io/#section/Limits)
                                                                   500, // [Internal Server Error](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.1)
                                                                   502, // [Bad Gateway](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.3)
                                                                   503, // [Service Unavailable](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.4)
                                                                   504 // [Gateway Timeout](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.5)
    ]
    
    public override init(
            retryLimit: UInt = RetryPolicy.defaultRetryLimit,
            exponentialBackoffBase: UInt = RetryPolicy.defaultExponentialBackoffBase,
            exponentialBackoffScale: Double = RetryPolicy.defaultExponentialBackoffScale,
            retryableHTTPMethods: Set<Alamofire.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods,
            retryableHTTPStatusCodes: Set<Int> = bfDefaultRetryableHTTPStatusCodes,
            retryableURLErrorCodes: Set<URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes
    ) {
        precondition(exponentialBackoffBase >= 2, "The `exponentialBackoffBase` must be a minimum of 2.")
        super.init(retryLimit: retryLimit, exponentialBackoffBase: exponentialBackoffBase, exponentialBackoffScale: exponentialBackoffScale, retryableHTTPMethods: retryableHTTPMethods, retryableHTTPStatusCodes: retryableHTTPStatusCodes, retryableURLErrorCodes: retryableURLErrorCodes)
    }
}

open class APIRequest {
    @discardableResult
    open func cancel() -> Bool { false }
}

open class RequestBuilder<T> {
    var credential: URLCredential?
    var headers: [String: String]
    var data: Data? = nil
    var config: BlockfrostConfig = BlockfrostConfig.shared()

    public let parameters: [String: Any]?
    public let method: String
    public let URLString: String

    /// Optional block to obtain a reference to the request's progress instance when available.
    /// With the URLSession http client the request's progress only works on iOS 11.0, macOS 10.13, macCatalyst 13.0, tvOS 11.0, watchOS 4.0.
    /// If you need to get the request's progress in older OS versions, please use Alamofire http client.
    public var onProgressReady: ((Progress) -> Void)?

    required public init(method: String, URLString: String, parameters: [String: Any]?, headers: [String: String] = [:], data: Data? = nil, config: BlockfrostConfig? = nil) {
        self.method = method
        self.URLString = URLString
        self.parameters = parameters
        self.headers = headers
        self.data = data

        if let cfg = config { self.config = cfg }
        addHeaders(self.config.customHeaders)
    }

    open func addHeaders(_ aHeaders: [String: String]) {
        for (header, value) in aHeaders {
            headers[header] = value
        }
    }

    @discardableResult
    open func execute(_ apiResponseQueue: DispatchQueue = BlockfrostConfig.shared().apiResponseQueue,
                      _ completion: @escaping (_ result: Swift.Result<Response<T>, Error>) -> Void) -> APIRequest {
        fatalError()
    }

    public func addHeader(name: String, value: String) -> Self {
        if !value.isEmpty {
            headers[name] = value
        }
        return self
    }

    open func addCredential() -> Self {
        credential = BlockfrostConfig.shared().credential
        return self
    }
}

public protocol RequestBuilderFactory {
    func getNonDecodableBuilder<T>() -> RequestBuilder<T>.Type
    func getBuilder<T: Decodable>() -> RequestBuilder<T>.Type
}

open class BaseService {
    var config: BlockfrostConfig = BlockfrostConfig.shared()

    public init(config: BlockfrostConfig? = nil) {
        self.config = config ?? BlockfrostConfig.shared()
    }

    @discardableResult
    open func completionWrapper<T>(
            _ apiResponseQueue: DispatchQueue? = nil,
            completion: @escaping (_ result: Swift.Result<T, Error>) -> Void,
            requestBuilder: () -> RequestBuilder<T>
    ) -> APIRequest {
        requestBuilder().execute(apiResponseQueue ?? config.apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(.success(response.body!))
            case let .failure(error):
                completion(.failure(error))
            }
        }
    }

    @discardableResult
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    open func asyncWrapper<T>(
            _ requestBuilder: () -> RequestBuilder<T>
    ) async throws -> T {
        var request: APIRequest?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                    continuation.resume(throwing: CancellationError())
                    return
                }

                let completion: (_ result: Swift.Result<Response<T>, Error>) -> Void = { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body!)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }

                request = requestBuilder().execute(config.apiResponseQueue) { result in completion(result) }
            }
        } onCancel: { [request] in
            request?.cancel()
        }
    }
}

public enum SortOrder: String, CaseIterable {
    case asc = "asc"
    case desc = "desc"
}
