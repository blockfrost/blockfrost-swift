// APIs.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Alamofire

//@available(*, deprecated, renamed: "BlockfrostSDK")
//public typealias OpenAPIClientAPI = BlockfrostSDK

open class BlockfrostConfig {
    public static var DEFAULT_COUNT = 100
    public static var DEFAULT_PAGE = 1
    public static var DEFAULT_SORT_ORDER = SortOrder.asc
    public static var DEFAULT_BATCH_SIZE = 10

    public var basePath = "https://cardano-mainnet.blockfrost.io/api/v0"
    public var customHeaders: [String: String] = [:]
    public var credential: URLCredential?
    public var projectId: String?
    public var requestBuilderFactory: RequestBuilderFactory = AlamofireRequestBuilderFactory()
    //public var requestBuilderFactory: RequestBuilderFactory = URLSessionRequestBuilderFactory()
    public var apiResponseQueue: DispatchQueue = .main
    public var batchSize: Int = DEFAULT_BATCH_SIZE

    // Alamofire dependent
    public var retryPolicy: RetryPolicy? = BlockfrostRetryPolicy()

    public init(basePath: String? = nil, projectId: String? = nil, apiResponseQueue: DispatchQueue? = nil, batchSize: Int? = nil, retryPolicy: RetryPolicy? = nil) {
        if let x = basePath { self.basePath = x }
        if let x = projectId { self.projectId = x }
        if let x = apiResponseQueue { self.apiResponseQueue = x }
        if let x = batchSize { self.batchSize = x }
        if let x = retryPolicy { self.retryPolicy = x }
    }

    private static var sharedInstance: BlockfrostConfig = {
        let instance = BlockfrostConfig()
        return instance
    }()
    
    public class func shared() -> BlockfrostConfig {
        sharedInstance
    }

    public func clone() -> BlockfrostConfig {
        let r = BlockfrostConfig()
        r.basePath = basePath
        r.customHeaders = customHeaders
        r.credential = credential
        r.projectId = projectId
        r.requestBuilderFactory = requestBuilderFactory
        r.apiResponseQueue = apiResponseQueue
        r.retryPolicy = retryPolicy
        return r
    }
}

open class BlockfrostStaticConfig {
    public static var basePath: String {
        get { BlockfrostConfig.shared().basePath }
        set { BlockfrostConfig.shared().basePath = newValue }}
    public static var customHeaders: [String: String] {
        get { BlockfrostConfig.shared().customHeaders }
        set { BlockfrostConfig.shared().customHeaders = newValue }}
    public static var credential: URLCredential? {
        get { BlockfrostConfig.shared().credential }
        set { BlockfrostConfig.shared().credential = newValue }}
    public static var projectId: String? {
        get { BlockfrostConfig.shared().projectId }
        set { BlockfrostConfig.shared().projectId = newValue }}
    public static var requestBuilderFactory: RequestBuilderFactory {
        get { BlockfrostConfig.shared().requestBuilderFactory }
        set { BlockfrostConfig.shared().requestBuilderFactory = newValue }}
    public static var apiResponseQueue: DispatchQueue {
        get { BlockfrostConfig.shared().apiResponseQueue }
        set { BlockfrostConfig.shared().apiResponseQueue = newValue }}
    public static var batchSize: Int {
        get { BlockfrostConfig.shared().batchSize }
        set { BlockfrostConfig.shared().batchSize = newValue }}
}

open class BlockfrostRetryPolicy : RetryPolicy {
    /// The default HTTP status codes to retry.
    /// See [RFC 2616 - Section 10](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10) for more information.
    public static let bfDefaultRetryableHTTPStatusCodes: Set<Int> = [408, // [Request Timeout](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.9)
                                                                   429, // [Rate limited](https://docs.blockfrost.io/#section/Limits)
                                                                   500, // [Internal Server Error](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.1)
                                                                   502, // [Bad Gateway](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.3)
                                                                   503, // [Service Unavailable](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.4)
                                                                   504 // [Gateway Timeout](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.5)
    ]
    
    public override init(
            retryLimit: UInt = RetryPolicy.defaultRetryLimit,
            exponentialBackoffBase: UInt = RetryPolicy.defaultExponentialBackoffBase,
            exponentialBackoffScale: Double = RetryPolicy.defaultExponentialBackoffScale,
            retryableHTTPMethods: Set<Alamofire.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods,
            retryableHTTPStatusCodes: Set<Int> = bfDefaultRetryableHTTPStatusCodes,
            retryableURLErrorCodes: Set<URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes
    ) {
        precondition(exponentialBackoffBase >= 2, "The `exponentialBackoffBase` must be a minimum of 2.")
        super.init(retryLimit: retryLimit, exponentialBackoffBase: exponentialBackoffBase, exponentialBackoffScale: exponentialBackoffScale, retryableHTTPMethods: retryableHTTPMethods, retryableHTTPStatusCodes: retryableHTTPStatusCodes, retryableURLErrorCodes: retryableURLErrorCodes)
    }
}

open class APIRequest {
    open func cancel() -> Bool { false }
}

open class RequestBuilder<T> {
    var credential: URLCredential?
    var headers: [String: String]
    var data: Data? = nil
    var config: BlockfrostConfig = BlockfrostConfig.shared()

    public let parameters: [String: Any]?
    public let method: String
    public let URLString: String

    /// Optional block to obtain a reference to the request's progress instance when available.
    /// With the URLSession http client the request's progress only works on iOS 11.0, macOS 10.13, macCatalyst 13.0, tvOS 11.0, watchOS 4.0.
    /// If you need to get the request's progress in older OS versions, please use Alamofire http client.
    public var onProgressReady: ((Progress) -> Void)?

    required public init(method: String, URLString: String, parameters: [String: Any]?, headers: [String: String] = [:], data: Data? = nil, config: BlockfrostConfig? = nil) {
        self.method = method
        self.URLString = URLString
        self.parameters = parameters
        self.headers = headers
        self.data = data

        if let cfg = config { self.config = cfg }
        addHeaders(self.config.customHeaders)
    }

    open func addHeaders(_ aHeaders: [String: String]) {
        for (header, value) in aHeaders {
            headers[header] = value
        }
    }

    open func execute(_ apiResponseQueue: DispatchQueue = BlockfrostConfig.shared().apiResponseQueue,
                      _ completion: @escaping (_ result: Swift.Result<Response<T>, Error>) -> Void) -> APIRequest {
        fatalError()
    }

    public func addHeader(name: String, value: String) -> Self {
        if !value.isEmpty {
            headers[name] = value
        }
        return self
    }

    open func addCredential() -> Self {
        credential = BlockfrostConfig.shared().credential
        return self
    }
}

public protocol RequestBuilderFactory {
    func getNonDecodableBuilder<T>() -> RequestBuilder<T>.Type
    func getBuilder<T: Decodable>() -> RequestBuilder<T>.Type
}

open class BaseService {
    var config: BlockfrostConfig = BlockfrostConfig.shared()

    public init(config: BlockfrostConfig? = nil) {
        self.config = config ?? BlockfrostConfig.shared()
    }
}

public enum SortOrder: String, CaseIterable {
    case asc = "asc"
    case desc = "desc"
}

public struct PaginationSetting: CustomStringConvertible, Hashable {
    public var count: Int = BlockfrostConfig.DEFAULT_COUNT
    public var page: Int = BlockfrostConfig.DEFAULT_PAGE
    public var order = BlockfrostConfig.DEFAULT_SORT_ORDER

    public init(count: Int? = nil, page: Int? = nil, order: SortOrder? = nil) {
        if let _count = count {
            self.count = _count
        }
        if let _page = page {
            self.page = _page
        }
        if let _order = order {
            self.order = _order
        }
    }

    public var description: String {
        "PaginationSetting(count: \(count), page: \(page), order: \(order))"
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(count)
        hasher.combine(page)
        hasher.combine(order)
    }
}

public struct AllMethodOptions: CustomStringConvertible {
    public var batchSize = BlockfrostConfig.DEFAULT_BATCH_SIZE
    public var order = BlockfrostConfig.DEFAULT_SORT_ORDER

    public init(batchSize: Int? = nil, order: SortOrder? = nil) {
        if let x = batchSize { self.batchSize = x }
        if let x = order { self.order = x }
    }

    public var description: String {
        "AllMethodOptions(batchSize: \(batchSize), order: \(order))"
    }
}
