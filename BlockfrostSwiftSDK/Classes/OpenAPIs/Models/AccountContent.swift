//
// AccountContent.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public final class AccountContent: Codable, Hashable {
    /** Bech32 stake address */
    public var stakeAddress: String
    /** Registration state of an account */
    public var active: Bool
    /** Epoch of the most recent action - registration or deregistration */
    public var activeEpoch: Int
    /** Balance of the account in Lovelaces */
    public var controlledAmount: String
    /** Sum of all rewards for the account in the Lovelaces */
    public var rewardsSum: String
    /** Sum of all the withdrawals for the account in Lovelaces */
    public var withdrawalsSum: String
    /** Sum of all  funds from reserves for the account in the Lovelaces */
    public var reservesSum: String
    /** Sum of all funds from treasury for the account in the Lovelaces */
    public var treasurySum: String
    /** Sum of available rewards that haven't been withdrawn yet for the account in the Lovelaces */
    public var withdrawableAmount: String
    /** Bech32 pool ID that owns the account */
    public var poolId: String?

    public init(stakeAddress: String, active: Bool, activeEpoch: Int, controlledAmount: String, rewardsSum: String, withdrawalsSum: String, reservesSum: String, treasurySum: String, withdrawableAmount: String, poolId: String?) {
        self.stakeAddress = stakeAddress
        self.active = active
        self.activeEpoch = activeEpoch
        self.controlledAmount = controlledAmount
        self.rewardsSum = rewardsSum
        self.withdrawalsSum = withdrawalsSum
        self.reservesSum = reservesSum
        self.treasurySum = treasurySum
        self.withdrawableAmount = withdrawableAmount
        self.poolId = poolId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case stakeAddress = "stake_address"
        case active
        case activeEpoch = "active_epoch"
        case controlledAmount = "controlled_amount"
        case rewardsSum = "rewards_sum"
        case withdrawalsSum = "withdrawals_sum"
        case reservesSum = "reserves_sum"
        case treasurySum = "treasury_sum"
        case withdrawableAmount = "withdrawable_amount"
        case poolId = "pool_id"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(stakeAddress, forKey: .stakeAddress)
        try container.encode(active, forKey: .active)
        try container.encode(activeEpoch, forKey: .activeEpoch)
        try container.encode(controlledAmount, forKey: .controlledAmount)
        try container.encode(rewardsSum, forKey: .rewardsSum)
        try container.encode(withdrawalsSum, forKey: .withdrawalsSum)
        try container.encode(reservesSum, forKey: .reservesSum)
        try container.encode(treasurySum, forKey: .treasurySum)
        try container.encode(withdrawableAmount, forKey: .withdrawableAmount)
        try container.encode(poolId, forKey: .poolId)
    }

    public static func == (lhs: AccountContent, rhs: AccountContent) -> Bool {
        lhs.stakeAddress == rhs.stakeAddress &&
            lhs.active == rhs.active &&
            lhs.activeEpoch == rhs.activeEpoch &&
            lhs.controlledAmount == rhs.controlledAmount &&
            lhs.rewardsSum == rhs.rewardsSum &&
            lhs.withdrawalsSum == rhs.withdrawalsSum &&
            lhs.reservesSum == rhs.reservesSum &&
            lhs.treasurySum == rhs.treasurySum &&
            lhs.withdrawableAmount == rhs.withdrawableAmount &&
            lhs.poolId == rhs.poolId
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(stakeAddress.hashValue)
        hasher.combine(active.hashValue)
        hasher.combine(activeEpoch.hashValue)
        hasher.combine(controlledAmount.hashValue)
        hasher.combine(rewardsSum.hashValue)
        hasher.combine(withdrawalsSum.hashValue)
        hasher.combine(reservesSum.hashValue)
        hasher.combine(treasurySum.hashValue)
        hasher.combine(withdrawableAmount.hashValue)
        hasher.combine(poolId.hashValue)
    }
}
