//
// EpochParamContent.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public final class EpochParamContent: Codable, Hashable {
    /** Epoch number */
    public var epoch: Int
    /** The linear factor for the minimum fee calculation for given epoch */
    public var minFeeA: Int
    /** The constant factor for the minimum fee calculation */
    public var minFeeB: Int
    /** Maximum block body size in Bytes */
    public var maxBlockSize: Int
    /** Maximum transaction size */
    public var maxTxSize: Int
    /** Maximum block header size */
    public var maxBlockHeaderSize: Int
    /** The amount of a key registration deposit in Lovelaces */
    public var keyDeposit: String
    /** The amount of a pool registration deposit in Lovelaces */
    public var poolDeposit: String
    /** Epoch bound on pool retirement */
    public var eMax: Int
    /** Desired number of pools */
    public var nOpt: Int
    /** Pool pledge influence */
    public var a0: Double
    /** Monetary expansion */
    public var rho: Double
    /** Treasury expansion */
    public var tau: Double
    /** Percentage of blocks produced by federated nodes */
    public var decentralisationParam: Double
    /** Seed for extra entropy */
    public var extraEntropy: AnyCodable?
    /** Accepted protocol major version */
    public var protocolMajorVer: Int
    /** Accepted protocol minor version */
    public var protocolMinorVer: Int
    /** Minimum UTXO value */
    public var minUtxo: String
    /** Minimum stake cost forced on the pool */
    public var minPoolCost: String
    /** Epoch number only used once */
    public var nonce: String
    /** The per word cost of script memory usage */
    public var priceMem: Double?
    /** The cost of script execution step usage */
    public var priceStep: Double?
    /** The maximum number of execution memory allowed to be used in a single transaction */
    public var maxTxExMem: String?
    /** The maximum number of execution steps allowed to be used in a single transaction */
    public var maxTxExSteps: String?
    /** The maximum number of execution memory allowed to be used in a single block */
    public var maxBlockExMem: String?
    /** The maximum number of execution steps allowed to be used in a single block */
    public var maxBlockExSteps: String?
    /** The maximum Val size */
    public var maxValSize: String?
    /** The percentage of the transactions fee which must be provided as collateral when including non-native scripts */
    public var collateralPercent: Double?
    /** The maximum number of collateral inputs allowed in a transaction */
    public var maxCollateralInputs: Int?
    /** The cost per UTxO word */
    public var coinsPerUtxoWord: String?

    public init(epoch: Int, minFeeA: Int, minFeeB: Int, maxBlockSize: Int, maxTxSize: Int, maxBlockHeaderSize: Int, keyDeposit: String, poolDeposit: String, eMax: Int, nOpt: Int, a0: Double, rho: Double, tau: Double, decentralisationParam: Double, extraEntropy: AnyCodable?, protocolMajorVer: Int, protocolMinorVer: Int, minUtxo: String, minPoolCost: String, nonce: String, priceMem: Double?, priceStep: Double?, maxTxExMem: String?, maxTxExSteps: String?, maxBlockExMem: String?, maxBlockExSteps: String?, maxValSize: String?, collateralPercent: Double?, maxCollateralInputs: Int?, coinsPerUtxoWord: String?) {
        self.epoch = epoch
        self.minFeeA = minFeeA
        self.minFeeB = minFeeB
        self.maxBlockSize = maxBlockSize
        self.maxTxSize = maxTxSize
        self.maxBlockHeaderSize = maxBlockHeaderSize
        self.keyDeposit = keyDeposit
        self.poolDeposit = poolDeposit
        self.eMax = eMax
        self.nOpt = nOpt
        self.a0 = a0
        self.rho = rho
        self.tau = tau
        self.decentralisationParam = decentralisationParam
        self.extraEntropy = extraEntropy
        self.protocolMajorVer = protocolMajorVer
        self.protocolMinorVer = protocolMinorVer
        self.minUtxo = minUtxo
        self.minPoolCost = minPoolCost
        self.nonce = nonce
        self.priceMem = priceMem
        self.priceStep = priceStep
        self.maxTxExMem = maxTxExMem
        self.maxTxExSteps = maxTxExSteps
        self.maxBlockExMem = maxBlockExMem
        self.maxBlockExSteps = maxBlockExSteps
        self.maxValSize = maxValSize
        self.collateralPercent = collateralPercent
        self.maxCollateralInputs = maxCollateralInputs
        self.coinsPerUtxoWord = coinsPerUtxoWord
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case epoch
        case minFeeA = "min_fee_a"
        case minFeeB = "min_fee_b"
        case maxBlockSize = "max_block_size"
        case maxTxSize = "max_tx_size"
        case maxBlockHeaderSize = "max_block_header_size"
        case keyDeposit = "key_deposit"
        case poolDeposit = "pool_deposit"
        case eMax = "e_max"
        case nOpt = "n_opt"
        case a0
        case rho
        case tau
        case decentralisationParam = "decentralisation_param"
        case extraEntropy = "extra_entropy"
        case protocolMajorVer = "protocol_major_ver"
        case protocolMinorVer = "protocol_minor_ver"
        case minUtxo = "min_utxo"
        case minPoolCost = "min_pool_cost"
        case nonce
        case priceMem = "price_mem"
        case priceStep = "price_step"
        case maxTxExMem = "max_tx_ex_mem"
        case maxTxExSteps = "max_tx_ex_steps"
        case maxBlockExMem = "max_block_ex_mem"
        case maxBlockExSteps = "max_block_ex_steps"
        case maxValSize = "max_val_size"
        case collateralPercent = "collateral_percent"
        case maxCollateralInputs = "max_collateral_inputs"
        case coinsPerUtxoWord = "coins_per_utxo_word"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(epoch, forKey: .epoch)
        try container.encode(minFeeA, forKey: .minFeeA)
        try container.encode(minFeeB, forKey: .minFeeB)
        try container.encode(maxBlockSize, forKey: .maxBlockSize)
        try container.encode(maxTxSize, forKey: .maxTxSize)
        try container.encode(maxBlockHeaderSize, forKey: .maxBlockHeaderSize)
        try container.encode(keyDeposit, forKey: .keyDeposit)
        try container.encode(poolDeposit, forKey: .poolDeposit)
        try container.encode(eMax, forKey: .eMax)
        try container.encode(nOpt, forKey: .nOpt)
        try container.encode(a0, forKey: .a0)
        try container.encode(rho, forKey: .rho)
        try container.encode(tau, forKey: .tau)
        try container.encode(decentralisationParam, forKey: .decentralisationParam)
        try container.encode(extraEntropy, forKey: .extraEntropy)
        try container.encode(protocolMajorVer, forKey: .protocolMajorVer)
        try container.encode(protocolMinorVer, forKey: .protocolMinorVer)
        try container.encode(minUtxo, forKey: .minUtxo)
        try container.encode(minPoolCost, forKey: .minPoolCost)
        try container.encode(nonce, forKey: .nonce)
        try container.encode(priceMem, forKey: .priceMem)
        try container.encode(priceStep, forKey: .priceStep)
        try container.encode(maxTxExMem, forKey: .maxTxExMem)
        try container.encode(maxTxExSteps, forKey: .maxTxExSteps)
        try container.encode(maxBlockExMem, forKey: .maxBlockExMem)
        try container.encode(maxBlockExSteps, forKey: .maxBlockExSteps)
        try container.encode(maxValSize, forKey: .maxValSize)
        try container.encode(collateralPercent, forKey: .collateralPercent)
        try container.encode(maxCollateralInputs, forKey: .maxCollateralInputs)
        try container.encode(coinsPerUtxoWord, forKey: .coinsPerUtxoWord)
    }

    public static func == (lhs: EpochParamContent, rhs: EpochParamContent) -> Bool {
        lhs.epoch == rhs.epoch &&
            lhs.minFeeA == rhs.minFeeA &&
            lhs.minFeeB == rhs.minFeeB &&
            lhs.maxBlockSize == rhs.maxBlockSize &&
            lhs.maxTxSize == rhs.maxTxSize &&
            lhs.maxBlockHeaderSize == rhs.maxBlockHeaderSize &&
            lhs.keyDeposit == rhs.keyDeposit &&
            lhs.poolDeposit == rhs.poolDeposit &&
            lhs.eMax == rhs.eMax &&
            lhs.nOpt == rhs.nOpt &&
            lhs.a0 == rhs.a0 &&
            lhs.rho == rhs.rho &&
            lhs.tau == rhs.tau &&
            lhs.decentralisationParam == rhs.decentralisationParam &&
            lhs.extraEntropy == rhs.extraEntropy &&
            lhs.protocolMajorVer == rhs.protocolMajorVer &&
            lhs.protocolMinorVer == rhs.protocolMinorVer &&
            lhs.minUtxo == rhs.minUtxo &&
            lhs.minPoolCost == rhs.minPoolCost &&
            lhs.nonce == rhs.nonce &&
            lhs.priceMem == rhs.priceMem &&
            lhs.priceStep == rhs.priceStep &&
            lhs.maxTxExMem == rhs.maxTxExMem &&
            lhs.maxTxExSteps == rhs.maxTxExSteps &&
            lhs.maxBlockExMem == rhs.maxBlockExMem &&
            lhs.maxBlockExSteps == rhs.maxBlockExSteps &&
            lhs.maxValSize == rhs.maxValSize &&
            lhs.collateralPercent == rhs.collateralPercent &&
            lhs.maxCollateralInputs == rhs.maxCollateralInputs &&
            lhs.coinsPerUtxoWord == rhs.coinsPerUtxoWord
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(epoch.hashValue)
        hasher.combine(minFeeA.hashValue)
        hasher.combine(minFeeB.hashValue)
        hasher.combine(maxBlockSize.hashValue)
        hasher.combine(maxTxSize.hashValue)
        hasher.combine(maxBlockHeaderSize.hashValue)
        hasher.combine(keyDeposit.hashValue)
        hasher.combine(poolDeposit.hashValue)
        hasher.combine(eMax.hashValue)
        hasher.combine(nOpt.hashValue)
        hasher.combine(a0.hashValue)
        hasher.combine(rho.hashValue)
        hasher.combine(tau.hashValue)
        hasher.combine(decentralisationParam.hashValue)
        hasher.combine(extraEntropy.hashValue)
        hasher.combine(protocolMajorVer.hashValue)
        hasher.combine(protocolMinorVer.hashValue)
        hasher.combine(minUtxo.hashValue)
        hasher.combine(minPoolCost.hashValue)
        hasher.combine(nonce.hashValue)
        hasher.combine(priceMem.hashValue)
        hasher.combine(priceStep.hashValue)
        hasher.combine(maxTxExMem.hashValue)
        hasher.combine(maxTxExSteps.hashValue)
        hasher.combine(maxBlockExMem.hashValue)
        hasher.combine(maxBlockExSteps.hashValue)
        hasher.combine(maxValSize.hashValue)
        hasher.combine(collateralPercent.hashValue)
        hasher.combine(maxCollateralInputs.hashValue)
        hasher.combine(coinsPerUtxoWord.hashValue)
    }
}
