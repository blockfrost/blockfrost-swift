//
// NetworkSupply.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public final class NetworkSupply: Codable, Hashable {
    /** Maximum supply in Lovelaces */
    public var max: String
    /** Current total (max supply - reserves) supply in Lovelaces */
    public var total: String
    /** Current circulating (UTXOs + withdrawables) supply in Lovelaces */
    public var circulating: String
    /** Curent locked supply by scripts in Lovelaces */
    public var locked: String

    public init(max: String, total: String, circulating: String, locked: String) {
        self.max = max
        self.total = total
        self.circulating = circulating
        self.locked = locked
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case max
        case total
        case circulating
        case locked
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(max, forKey: .max)
        try container.encode(total, forKey: .total)
        try container.encode(circulating, forKey: .circulating)
        try container.encode(locked, forKey: .locked)
    }

    public static func == (lhs: NetworkSupply, rhs: NetworkSupply) -> Bool {
        lhs.max == rhs.max &&
            lhs.total == rhs.total &&
            lhs.circulating == rhs.circulating &&
            lhs.locked == rhs.locked
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(max.hashValue)
        hasher.combine(total.hashValue)
        hasher.combine(circulating.hashValue)
        hasher.combine(locked.hashValue)
    }
}
