//
// NutlinkAddress.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public final class NutlinkAddress: Codable, Hashable {
    /** Bech32 encoded address */
    public var address: String
    /** URL of the specific metadata file */
    public var metadataUrl: String
    /** Hash of the metadata file */
    public var metadataHash: String
    /** The cached metadata of the `metadata_url` file. */
    public var metadata: [String: AnyCodable]?

    public init(address: String, metadataUrl: String, metadataHash: String, metadata: [String: AnyCodable]?) {
        self.address = address
        self.metadataUrl = metadataUrl
        self.metadataHash = metadataHash
        self.metadata = metadata
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case address
        case metadataUrl = "metadata_url"
        case metadataHash = "metadata_hash"
        case metadata
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(address, forKey: .address)
        try container.encode(metadataUrl, forKey: .metadataUrl)
        try container.encode(metadataHash, forKey: .metadataHash)
        try container.encode(metadata, forKey: .metadata)
    }

    public static func == (lhs: NutlinkAddress, rhs: NutlinkAddress) -> Bool {
        lhs.address == rhs.address &&
            lhs.metadataUrl == rhs.metadataUrl &&
            lhs.metadataHash == rhs.metadataHash &&
            lhs.metadata == rhs.metadata
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address.hashValue)
        hasher.combine(metadataUrl.hashValue)
        hasher.combine(metadataHash.hashValue)
        hasher.combine(metadata.hashValue)
    }
}
