//
// ScriptRedeemer.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public final class ScriptRedeemer: Codable, Hashable {
    public enum Purpose: String, Codable, CaseIterable {
        case spend
        case mint
        case cert
        case reward
    }

    /** Hash of the transaction */
    public var txHash: String
    /** The index of the redeemer pointer in the transaction */
    public var txIndex: Int
    /** Validation purpose */
    public var purpose: Purpose
    /** The budget in Memory to run a script */
    public var unitMem: String
    /** The budget in CPU steps to run a script */
    public var unitSteps: String
    /** The fee consumed to run the script */
    public var fee: String

    public init(txHash: String, txIndex: Int, purpose: Purpose, unitMem: String, unitSteps: String, fee: String) {
        self.txHash = txHash
        self.txIndex = txIndex
        self.purpose = purpose
        self.unitMem = unitMem
        self.unitSteps = unitSteps
        self.fee = fee
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case txHash = "tx_hash"
        case txIndex = "tx_index"
        case purpose
        case unitMem = "unit_mem"
        case unitSteps = "unit_steps"
        case fee
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(txHash, forKey: .txHash)
        try container.encode(txIndex, forKey: .txIndex)
        try container.encode(purpose, forKey: .purpose)
        try container.encode(unitMem, forKey: .unitMem)
        try container.encode(unitSteps, forKey: .unitSteps)
        try container.encode(fee, forKey: .fee)
    }

    public static func == (lhs: ScriptRedeemer, rhs: ScriptRedeemer) -> Bool {
        lhs.txHash == rhs.txHash &&
            lhs.txIndex == rhs.txIndex &&
            lhs.purpose == rhs.purpose &&
            lhs.unitMem == rhs.unitMem &&
            lhs.unitSteps == rhs.unitSteps &&
            lhs.fee == rhs.fee
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(txHash.hashValue)
        hasher.combine(txIndex.hashValue)
        hasher.combine(purpose.hashValue)
        hasher.combine(unitMem.hashValue)
        hasher.combine(unitSteps.hashValue)
        hasher.combine(fee.hashValue)
    }
}
